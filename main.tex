\documentclass{article}
\usepackage[T2A]{fontenc}
\usepackage{graphicx} % Required for inserting images
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[paperheight=6in,
   paperwidth=5in,
   top=10mm,
   bottom=20mm,
   left=10mm,
   right=10mm]{geometry}
   \usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82} 


\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{mauve},
  breaklines=false,
  breakatwhitespace=false,
  tabsize=3
}
\title{Scheduling problem}
\author{Константин Волков и Никита Измайлов}
\date{November 2023}
\setlength{\parindent}{20pt}
\begin{document}
\maketitle


\section{Поставновка задачи.} 
\textbf{Составление расписания}

Пусть имеются: \par
\begin{itemize}
\item \(\mathnormal{N}\) преподавателей: \(x_1  ...  x_n \);
\item \(\mathnormal{M}\) групп студентов \(y_1  ...  y_m \);
\item \(a_i \in \mathcal{N}_0\) - максимальное число пар которое может провести \(i\)-ый преподаватель в день.
\end{itemize}

Введем в рассмотрение матрицу недели \(W_{[n \times m]}\), где \(W[i][j] = \) количеству пар которое \(i\)-ый преподаватель ведет у \(j\)-ой группы в течение недели. \\
Пусть \(D_k\) - аналогичная матрица дня, где  \(D[i][j] = \) количеству пар которое \(i\)-ый преподаватель ведет у \(j\)-ой группы в течении \(k\)-ого дня. \\
\[\Rightarrow W = \sum_{k=1}^{7} D_k\]

\textit{Определение:} набор матриц дней \(D_{1...7}^{*}\) назовем приемлемым для матрицы недели W если:
\begin{itemize}
\item \(W = \sum_{k=1}^{7} D_k^{*}\)
\item \(\forall k \in [1...7], \forall i \in [1...n] \Rightarrow \sum_{j = 1}^{m} D_k^{*}[i][j] < a_i \)
\end{itemize}
Будем считать что в течении одного дня одна группа может посетить не более чем \(s\) пар.

\par
\textit{Определение:} Матрицей расписания \(k\)-ого дня назовем матрицу \(Sch_{[m \times s]}^{k}\) элементами которой являются \(x \in \{x_1...x_n\} \cup \{0\}\), причем \(Sch^{k}[i][j]\) - преподаватель который ведет \(j\)-ую пару у \(i\)-ой группы в \(k\)-ый день. (в случае  \(Sch^{k}[i][j]\) = \(0\) считаем что пары нет)
\par
\textit{Определение:} Матрицу расписания \(k\)-ого дня назовем оптимальной если 
\begin{itemize}
    \item \(\forall i \in [1...n] \Rightarrow Sch^{k}[i] = [0, 0, .., x_a, .., x_b,.. 0]\). Т.е. вектор элеметы которого не равны нулю начинает с некоторого \(a\) и заканчивая некоторым \(b\) где \(1 <= a, b <= n\) \\ (Это условие того что в расписании нет окон)
     \item \(\forall  j \in [1...m] \Rightarrow Sch^{k}[i_1][j] \neq Sch^{k}[i_2][j] \forall i_1 \neq i_2 \). Т.е. Преподаватель не ведет две пары одновременно
\end{itemize}

\par
\textit{Определение:} Матрицей расписания назовем матрицу \(Sch_{[m \times 7s]} = (Sch^{1}|....|Sch^{7})\).
Матрица расписания называется оптимальной если \(\forall k \in [1...7] \Rightarrow Sch^{k}\) - оптимальная 
\par
\textit{Определение:} Величина \(Count^{k}(j, x)\) -  количество элементов равных \(x\) в \(j\)-ой строке матрицы \(Sch^{k}\)
\par
\textit{Определния:} Матрице расписания \(k\)-го дня   \(Sch^{k}\) \textbf{соотвествует} матрица дня \(D_k\) \(<=> D_k[i][j] = Count^{k}(j, x_i)\) 
\par
Теперь мы можем  сформулировать задачу составления расписания
\par
\textit{Задача:} По известным W, \(a_1...a_n\), составить оптимальную матрицу расписания \(Sch:\) матрицы дней \(D_k\),  соотвествующие матрицам \(Sch^{k}\), образуют
приемлимый набор для матрицы W
\section{Подход к решению.} 
\textit{Идея:} Матрицы \(Sch^{k}\) и \(D_k\) очевидно сильно связаны между собой. Идея решения заключается в том, чтобы научиться по \(D_k\) строить наилучшую в некотором смысле \(Sch^{k}\), и оценивать полученную матрицу на предмет того, насколько она далека от оптимальой. Таким образом задача сведеться к поиску приемлемого набора матрицы, для которого набор матриц \(Sch^{k}\), будет наилучшим в терминах нашего оценивания
\subsection{Переход от  матрицы дня к матрице расписания}
Предположим что нам известна некоторая матрица дня \(D\) и мы хотим составить такую матрицу расписание \(Sch(D)\), которой соотвествует D, и которая была бы масксимально прибижена к оптимальной.
\\Опишем алгоритм позволяющий это сделать.
\par
\textit{Алгоритм:} Создадим начальную матрицу \(M_{[m \times s]}\) по следующему правилу: \\
\begin{itemize}
\item  Инициализируем матрицу нужной размерности
   заполненую нулями 
\item Для всех \(j \in 1...m\) по \(j\) - ому столбцу матрици D и  ставим \(x_i\) в самую левую неравную нулю клетку \(j\) - ой строки матрици M, и делаем это \( D[i][j]\)
раз для всех i
\end{itemize}
Таким образом мы получаем матрицу \(M\), соотвествующую матрице D,, для которой каждая строка имеет вид \([x_{i_1} ... x_{i_a}, 0 ... 0]\) где \( a \in 0...s\), то есть в текущей матрице "нет окон" и  у каждой группы занятия начинаются с первой пары. Тем не менее матрица M все еще может быть не оптимальной матрицей расписания, так как могут существовать  \( i1, i2, j: M[i_1][j] = M[i_2][j]\). Назовем такие тройки индексов - "противоречием".  
\par
Введем вспомогательную функцию \(coutr(i, j) = \) количеству элементов в j этом столбце равных \(M[i][j]\), т.е. \(countr(i, j) >= 1 \) \\ 
Если переставить местами любой строки \(M\), она не перестанет соотвествовать матрице \(D\), значит мы можем использовать такие переставно чтобы "оптимизировать" матрицу M. Итак алгоритм:
\begin{enumerate}
    \item Пусть \(j = 1, err = 0\)
    \item Создаем список, в котором мы будем хранить элементы которые ранее были встреченны в текущем столбце (\(j\) - ом). Назовем его \(Set\)
    \item Пусть \(i = 1\)
    \item Если \(M[i][j] == 0\), тогда  \(i = i + 1\), и если \(i <= s\), вернуться к шагу 4.
    \item Если \(Set\) не содержит \(M[i][j]\) то, добаляем его в \(Set\). \\ \(i = i + 1\), и если \(i <= s\),
    вернуться к шагу 4, иначе перейти на шаг 10.
    \item (Если мы доходим до этого шага то мы нашли преподавателя который ведет два пары одновременно) 
    Пусть \(k = 1\), \(minCount = \infty\),  \( swapIndex = k \)
    \item Если \(Set\) содержит \(M[i][k]\) или \(M[i][k] == 0\) или \(j == k\), \(k = k + 1\), перейти на шаг 9  если \(k > s\)
    \item Swap(\(M[i][k], M[i][j]\)), пусть \(count = countr(i, j) + countr(i ,k)\). \\Если \(minCount > count\), тогда \(minCount = count, swapIndex = k \). Swap(\(M[i][k], M[i][j]\)), \(k = k + 1\), вернуться к шагу 7 если \(k <= s\)
    \item Если \(swapIndex == j \), тогда \(err = err + 1\), иначе Swap(\(M[i][swapIndex], M[i][j]\)). добаляем \(M[i][j]\) в \(Set\), \(i = i + 1\), и если \(i <= s\),
    вернуться к шагу 4
    \item \(j = j + 1\), если \(j <= m\), вернуться в шагу 2, иначе вернуть \(err\) и закочить работу
\end{enumerate}
Таким образом, число \(err\), показывает сколько "противоречивых" клеток содержит наша матрица, если это значение равно 0, то матрица оптимальна.
\par
\textit{Как и почему это работает?} Мы изменяем расписание только перестановками элементов строк, то есть расписание остается соотвествующим матрице \(D\). Кроме того каждый раз, когда мы находим "противоречие" в матрице, мы находим такой элемент в текующий строке, перестановка текущего с которым, преводит к появлению наименьшего числа "противоречий", таким образом если с помощью перестановок можно привести матрицу к оптимальной, то мы это сделаем (строго доказать!!!!). При этом мы делаем только такие перестановки, которые не приводят к появлению "окон".

\par
\textit{Все ли мы учитываем?} Нет. в теории мы можем добиться лучшего результата, если скажем, для некоторой группы пары будут начинаться не с первой, а с  \(n\) - ой пары. Кроме того, в некоторых ситуациях имеет смысл отказаться от запрета на создание "окон" в расписании, чтобы уменьшить число "противоречий". 
\par
Пример реализации на Python:
\begin{lstlisting}
def order_timetable(matr):
    err = 0
    for j in range(len(matr[0])):
        set_ = set([])
        for i in range(len(matr)):
            if matr[i][j] == 0:
                continue
            swap_index = j
            if matr[i][j] in set_:
                min_count = len(matr)
                for k in range(len(matr[0])):
                    if (matr[i][k] not in set_) and (matr[i][k] != 0) and j != k:
                        matr[i][j], matr[i][k] = matr[i][k], matr[i][j]
                        count_elem = count(matr, i, k) + count(matr,i, j)
                        if min_count >= count_elem:
                            min_count = count_elem
                            swap_index = k
                        matr[i][j], matr[i][k] = matr[i][k], matr[i][j]
                if swap_index != j:
                    matr[i][j], matr[i][swap_index] = matr[i][swap_index], matr[i][j]
                else:
                   err += 1
            set_.add(matr[i][j])
           
            
    return err
\end{lstlisting}
\subsection{Генетический алгоритм}
Описать селекцию, кроссовер. мутацию
//
https://dspace.bracu.ac.bd/xmlui/bitstream/handle/10361/4902/12101108.pdf?sequence=1&isAllowed=y
\end{document}
